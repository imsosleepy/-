# 추천사 & 시작하며
카프카 : 스트리밍 플랫폼으로 정의

MQ 메시징 시스템이라 생각하기 쉬우나 차이점이 여럿 있음
1. 현대적인 분산 시스템 : 일반적인 하드웨이 위에서 분산 클라스터 형태로 작동, 신축성있게 확장 가능
2. 원하는 만큼 오랫동안 데이터를 저장할 수 있음
3. 높은 추상화 수준

# Chapter 1. 카프카 시작하기
## 1.1 발행/구독 메시지 전달
> 과학자들이 서로 동의하지 않는 상황이 벌어진다면, 그것은 데이터가 불충분하기 때문이다. 그리고 어떠한 데이터를 얻을 것인지를 합의하고 데이터를 얻을 수 있다면 문제는 해결된다. 내가 옳든 상대방이 옳든, 아니면 둘 다 틀리든 말이다. 그제서야 우리는 그 다음으로 진행해 갈 수 있다

초기의 발행/구독 시스템은 직접 연결되어서 확장성이 부족해서 애플리케이션이 늘어감에 따라 복잡한 의존 관계가 생김
-> 기술 부채가 발생

개별 메시지 큐 시스템을 도입함으로 의존 관계에서는 벗어났으나, 필요에 따라 큐가 증가하게 되고 이는 유지 관리의 어려움과 중복을 발생시킴
-> 메시지큐의 중앙 관리의 필요성이 대두

## 1.2 카프카 입문
용어 정리 : GPT의 도움을 받음
### 1. 메시지
   - 정의: Kafka에서 다루는 데이터의 기본 단위입니다. 
   - 메타데이터: 메시지에는 본문(데이터)뿐 아니라 추가 정보(키, 타임스탬프, 헤더 등)가 포함됩니다.
   - 키: 메시지의 메타데이터 중 하나로, 메시지를 특정 파티션에 분배하는 데 사용됩니다. 동일한 키를 가진 메시지는 항상 같은 파티션에 저장됩니다.
   - 예시: 주문 시스템에서 메시지는 "주문 정보"이며, 키는 "주문 ID"가 될 수 있습니다.
### 2. 배치 
   - 정의: 카프카는 메시지를 효율적으로 처리하기 위해 여러 메시지를 묶어 한 번에 저장하거나 전송합니다. 이 묶음을 **배치(Batch)**라고 합니다.
   - 동일한 토픽과 파티션에 속한 메시지를 하나의 배치로 그룹화합니다.
   - 배치 처리를 통해 네트워크 비용을 줄이고 성능을 최적화합니다.
   - 예시: 주문 데이터가 10개 도착했을 때, 이를 각각 처리하지 않고 한 번에 묶어서 저장하거나 전송합니다.
### 3. 스키마 
   - 정의: 메시지의 구조를 정의한 규칙입니다.
   - 스키마는 데이터의 필드 이름, 데이터 타입, 구조 등을 정의하여 메시지를 이해하고 처리하기 쉽게 만듭니다.
   - Kafka에서 주로 Avro나 JSON 스키마를 사용합니다.
   - 스키마 레지스트리(Schema Registry): 스키마를 관리하는 Kafka의 도구로, 프로듀서와 컨슈머가 동일한 데이터 구조를 사용할 수 있도록 합니다.
      ```json
     {
        "order_id": "1234",
        "amount": 500,
        "currency": "USD"
      }
     ```
     ![img_1.png](image/img_1.png)
###  4. 토픽 
   - 정의: 메시지가 분류되는 단위입니다. DB의 테이블에 비유할 수 있습니다.
   - 프로듀서가 메시지를 보낼 때, 특정 토픽으로 메시지를 전송합니다.
   - 컨슈머는 특정 토픽을 구독하여 해당 토픽의 메시지를 소비합니다.
   - 예시: 전자상거래 시스템에서 주문 데이터를 담는 "orders"라는 토픽과 결제 데이터를 담는 "payments"라는 토픽이 있을 수 있습니다.
###  5. 파티션 
   - 정의: 각 토픽은 여러 파티션으로 나뉘어 분산 저장됩니다.
   - 한 토픽의 메시지는 여러 파티션에 나뉘어 저장되며, 각 파티션은 Kafka 브로커에 분산됩니다.
   - 파티션을 통해 Kafka는 수평적으로 확장할 수 있으며, 높은 처리량과 병렬 처리를 지원합니다.
   - 메시지는 키를 기준으로 특정 파티션에 저장됩니다.
   - 예시: "orders" 토픽이 3개의 파티션(P0, P1, P2)으로 나뉘고, 키가 "1234"인 메시지는 P0에 저장됩니다.
###  6. 브로커 
   - 정의: Kafka 클러스터를 구성하는 개별 서버입니다.
   - 각 브로커는 파티션의 일부를 저장하고, 프로듀서와 컨슈머의 요청을 처리합니다.
   - 브로커는 클러스터에 연결되어 서로 협력합니다.
   - 브로커마다 고유한 ID를 가지며, 하나의 Kafka 클러스터에는 여러 브로커가 있을 수 있습니다.
   - 예시: 브로커 1은 P0와 P1을 관리하고, 브로커 2는 P2를 관리합니다.
### 7. 클러스터
- 정의: 여러 브로커가 모여 하나의 Kafka 클러스터를 구성합니다.
- Kafka 클러스터는 메시지의 저장과 처리를 분산하여 수행합니다.
- 클러스터 내의 모든 브로커는 ZooKeeper 또는 KRaft를 통해 상태를 공유합니다.
- 예시: 클러스터에는 5개의 브로커가 포함될 수 있으며, 각 브로커는 여러 파티션을 관리합니다.
### 8. 파티션 리더
- 정의: 각 파티션에는 리더(Leader) 브로커가 있으며, 메시지의 읽기 및 쓰기 작업을 담당합니다.
- 프로듀서와 컨슈머는 항상 리더를 통해 작업을 수행합니다.
- 리더는 클러스터에서 동적으로 선출되며, 장애가 발생하면 새로운 리더가 지정됩니다.
- 예시: P0의 리더가 브로커 1이라면, P0의 모든 읽기 및 쓰기 요청은 브로커 1에서 처리됩니다.
### 9. 팔로워
- 정의: 리더의 데이터를 복제한 파티션을 관리하는 브로커입니다.
- 팔로워는 리더를 복제하여 데이터를 보존하며, 리더가 장애를 겪을 경우 새로운 리더로 승격될 준비를 합니다.
- 복제본: 팔로워는 리더의 복제본을 유지합니다.
- 예시: P0의 복제본이 브로커 2와 브로커 3에 있다면, 이 두 브로커는 팔로워입니다.
### 복제가 필요한 이유
   고가용성: 리더 브로커가 장애를 겪더라도 팔로워가 리더로 승격되어 서비스를 지속합니다.
   데이터 손실 방지: 데이터가 복제되어 있으므로 단일 브로커 장애로 인해 데이터가 유실되지 않습니다.


## 1.3 왜 카프카인가?
다중 프로듀서, 다중 컨슈머, 디스크 기반 보존, 확장성, 고성능, 플랫폼 기능

## 1.4 데이터 생태계
모든 클라이언트에 대해 일관된 인터페이스를 제공하면서 다양한 인프라스트럭쳐 요소들 사이에 메시지를 전달
이용사례 : 활동 추적, 메시지 교환, 지표 및 로그 수집, 커밋 로그 , 스트림 처리

## 1.5 카프카의 기원
링크드인이 확장됨에 따라 커스텀하게 필요한 기능은 많고, 고가용성이 필수적인데 핏한 오픈소스나 MQ 제품이 없어서, 커스텀 인프라스터럭처가 필요하게 됨

## 정리
1장은 용어 위주로 정리해보려고 함. 아직 잘 되진 않음. k8s를 처음 공부할 때도 용어에 대해 정의가 잘 되지 않았는데 비슷한 상황을 겪으리라 생각됩니다.